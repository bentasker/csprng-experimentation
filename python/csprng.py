#!/usr/bin/env python3
#
# Playing around with creating a CSPRNG
#
# *DO NOT* use this in production for anything that matters
#

from Crypto.Cipher import ChaCha20
import os
import base64


# This is based on the mitigations deployed in Amazon's S2N - https://aws.amazon.com/blogs/opensource/better-random-number-generation-for-openssl-libc-and-linux-mainline/
#
# Mix a little randomness into each number (so that if we somehow end up with different threads running with the same seed we still get different results, preventing leakage between public and private contexts)
#
# Amazon use RDRAND - that's a tad tricky when you're tinkering with this on a Pi that doesn't have that instruction.
#
# Enabling this means that you'll no longer be generating deterministic output
prediction_resistant=False


# Hardcoding our seed in for now
#
# This is the output of my entropy collection/distribution script. It'll always return 512 bits
randomdata=base64.b64decode("MjFfijwAV65CR12tom/BL2MfuMTmVJXD69pGV7gnVj0X9F/LxKpcwYGtD5/0CL3mnMjHKGmpOowbSb1KlXB5dw==")


def ChaChaMe(key,nonce,plaintext):
    '''
        Take a key and a "plaintext" (which in this case is probably a string of random bytes)
        ChaCha20 them and return
    '''
    cipher=ChaCha20.new(key=key,nonce=nonce)
    return cipher.encrypt(plaintext)


def iterate_with(key,plaintext,itercount,prediction_resistant):
    '''
        Iteratively reencrypt a keyset with itself - itercount iterations
    
    '''
    buffer1 = []
    # 48 iterations
    for i in range(1,itercount):
        
        # Use counter-mode to generate our nonce for each encryption
        #
        # When this iteration loop is next called, the key will have changed
        nonce=format(i,'012').encode('utf-8')
        
        # Trigger the encryption
        plaintext = ChaChaMe(key,nonce,plaintext)
        
        if prediction_resistant:
            plaintext = mix_with_rand(plaintext)
        
        
        buffer1.append(plaintext)
    return buffer1, plaintext


def populate_global_buffer(buffer1):
    '''
        Push generated bytes into a buffer for consumption later
        
        When I'm done tinkering, this'll end up being a queue which we'll write to
        and overwrite regularly
    '''
    global buffer
    for e in buffer1[2:]:
        buffer.append(e)

    # Combine the first 2 positions to formulate our new key
    key=bytes([a ^ b for a,b in zip(buffer[0],buffer[1])])
    return key


def mix_with_rand(plaintext):
    '''
        Take the input bytes and mix with data from a new random source
    '''
    randbytes = bytefetch(32)
    
    return bytes([a ^ b for a,b in zip(randbytes,plaintext)])


# Main

# If prediction resistance is enabled, try and enable RDRAND. Fall back on `get_random_bytes` if not
if prediction_resistant:
    fail=False
    try:
        import rdrand
    except:
        fail=True
        
    if not fail and rdrand.HAS_RAND:
        bytefetch = rdrand.rdrand_get_bytes
    else:
        from Crypto.Random import get_random_bytes
        bytefetch = get_random_bytes
    

buffer = [] # This is the output buffer. We'd prob make it a queue

# Split our random data up to form a key and an input seed
key=randomdata[0:32]
plaintext=randomdata[32:] # this is another 32 bytes


# Build up 100 iterations worth of blocks
for i in range(0,100):
    # Set off the initial iteration (48 iterations)
    buffer1, plaintext = iterate_with(key,plaintext,48,prediction_resistant)

    # Clear the original and then use the first 2 entries to create the next key
    # use the rest of the chain as our bytes
    del key
    key = populate_global_buffer(buffer1)

    # Clear the old one out
    del buffer1


# Write the bytes out to a file (makes it easier for me to run through ent etc for now)
fh = os.open('op',os.O_RDWR)
for i in buffer:
    os.write(fh,i)

os.close(fh)

# Print it out just to prove to me that we did something
print(buffer)

