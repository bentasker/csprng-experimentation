#!/usr/bin/env python3
#
# Playing around with creating a CSPRNG
#
# *DO NOT* use this in production for anything that matters
#

from Crypto.Cipher import ChaCha20
import os
import base64


# Hardcoding our seed in for now
#
# This is the output of my entropy collection/distribution script. It'll always return 512 bits
randomdata=base64.b64decode("MjFfijwAV65CR12tom/BL2MfuMTmVJXD69pGV7gnVj0X9F/LxKpcwYGtD5/0CL3mnMjHKGmpOowbSb1KlXB5dw==")


def ChaChaMe(key,nonce,plaintext):
    '''
        Take a key and a "plaintext" (which in this case is probably a string of random bytes)
        ChaCha20 them and return
    '''
    cipher=ChaCha20.new(key=key,nonce=nonce)
    return cipher.encrypt(plaintext)


def iterate_with(key,plaintext,itercount):
    '''
        Iteratively reencrypt a keyset with itself - itercount iterations
    
    '''
    buffer1 = []
    # 48 iterations
    for i in range(1,itercount):
        
        # Use counter-mode to generate our nonce for each encryption
        #
        # When this iteration loop is next called, the key will have changed
        nonce=format(i,'012').encode('utf-8')
        
        # Trigger the encryption
        plaintext = ChaChaMe(key,nonce,plaintext)
        buffer1.append(plaintext)
    return buffer1, plaintext


def populate_global_buffer(buffer1):
    '''
        Push generated bytes into a buffer for consumption later
        
        When I'm done tinkering, this'll end up being a queue which we'll write to
        and overwrite regularly
    '''
    global buffer
    for e in buffer1[2:]:
        buffer.append(e)

    # Combine the first 2 positions to formulate our new key
    key=bytes([a ^ b for a,b in zip(buffer[0],buffer[1])])
    return key





# Main
buffer = [] # This is the output buffer. We'd prob make it a queue

# Split our random data up to form a key and an input seed
key=randomdata[0:32]
plaintext=randomdata[32:] # this is another 32 bytes


# Build up 100 iterations worth of blocks
for i in range(0,100):
    # Set off the initial iteration (48 iterations)
    buffer1, plaintext = iterate_with(key,plaintext,48)

    # Clear the original and then use the first 2 entries to create the next key
    del key

    # Extract bytes from the rest of the chain
    key = populate_global_buffer(buffer1)

    # Clear the old one out
    del buffer1

# Write the bytes out to a file (makes it easier for me to run through ent etc for now)
fh = os.open('op',os.O_RDWR)
for i in buffer:
    os.write(fh,i)

os.close(fh)

# Print it out just to prove to me that we did something
print(buffer)